<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ColorAid – Corrección Rápida</title>

<style>
    body { margin:0; font-family:Arial, sans-serif; background:#f2f2f2; text-align:center; padding-bottom: 50px; }
    header { background:#005bbb; padding:15px; color:white; font-size:22px; font-weight: bold; }
    h2 { margin-top:25px; color: #333; }
    
    .mode-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
        padding: 10px;
    }

    .mode-btn, .action-btn, .close-btn {
        background:white; padding:12px; 
        width: 100%; max-width:300px; border-radius:10px;
        border-left:6px solid #007bff; cursor:pointer;
        font-size:16px; user-select: none;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        margin: 5px auto;
    }
    
    .mode-btn:active, .action-btn:active { transform: scale(0.98); }
    .action-btn { background:#007bff; color:white; border-left:none; }
    .close-btn { background:#ff3b3b; color:white; border-left:none; display: none; } /* Oculto por defecto */
    
    /* El canvas se estira por CSS para verse bien, pero internamente será pequeño para ser rápido */
    canvas {
        width:90%; max-width:400px; margin-top:15px;
        border-radius:10px; background:black;
        display: block; margin-left: auto; margin-right: auto;
    }
    
    #videoElement { display: none; } /* El video original siempre oculto */
</style>
</head>

<body>

<header>ColorAid</header>

<h2>1. Selecciona el modo</h2>
<div class="mode-container">
    <div class="mode-btn" onclick="setMatrix('deuteranopia')">Deuteranopia (Rojo/Verde)</div>
    <div class="mode-btn" onclick="setMatrix('protanopia')">Protanopia (Rojo opaco)</div>
    <div class="mode-btn" onclick="setMatrix('tritanopia')">Tritanopia (Azul/Amarillo)</div>
</div>

<h2>2. Subir imagen</h2>
<input type="file" id="imageInput" accept="image/*">
<canvas id="imageCanvas"></canvas>

<h2>3. Cámara en vivo</h2>
<div class="action-btn" id="btnStart" onclick="startCamera()">Activar cámara</div>
<div class="close-btn" id="btnStop" onclick="stopCamera()">Detener cámara</div>

<canvas id="videoCanvas" style="display:none;"></canvas>

<video id="videoElement" autoplay playsinline></video>

<script>
// --- VARIABLES GLOBALES ---
let selectedMatrix = null; // Inicialmente nulo
let cameraStream = null;
let cameraRunning = false;
let animationId = null;

// --- MATRICES 3×3 ---
const matrices = {
    deuteranopia: [
        [0.625, 0.375, 0.000],
        [0.700, 0.300, 0.000],
        [0.000, 0.300, 0.700]
    ],
    protanopia: [
        [0.567, 0.433, 0.000],
        [0.558, 0.442, 0.000],
        [0.000, 0.242, 0.758]
    ],
    tritanopia: [
        [0.950, 0.050, 0.000],
        [0.000, 0.433, 0.567],
        [0.000, 0.475, 0.525]
    ]
};

// Establecer matriz por defecto (opcional) o esperar click
// selectedMatrix = matrices.deuteranopia; 

function setMatrix(type){
    selectedMatrix = matrices[type];
    alert("Modo activado: " + type); // Feedback visual simple
    
    // Si hay una imagen cargada estática, reaplicar filtro
    if(originalImg.src && !cameraRunning){ 
        applyMatrixToImage(); 
    }
}

// ---------------- LÓGICA DE IMAGEN ESTÁTICA ------------------
let originalImg = new Image();
const imageCanvas = document.getElementById("imageCanvas");
const imgCtx = imageCanvas.getContext("2d");

document.getElementById("imageInput").addEventListener("change", function(e){
    const file = e.target.files[0];
    if(!file) return;
    
    // Detener cámara si se sube foto para ahorrar recursos
    if(cameraRunning) stopCamera();

    const reader = new FileReader();
    reader.onload = function(event){
        originalImg = new Image();
        originalImg.onload = function(){
            // Ajustar tamaño del canvas a la imagen (limitando si es gigante)
            const MAX_IMG_WIDTH = 800;
            let scale = 1;
            if(originalImg.width > MAX_IMG_WIDTH){
                scale = MAX_IMG_WIDTH / originalImg.width;
            }
            imageCanvas.width = originalImg.width * scale;
            imageCanvas.height = originalImg.height * scale;

            // Dibujar imagen original redimensionada
            imgCtx.drawImage(originalImg, 0, 0, imageCanvas.width, imageCanvas.height);
            
            // Aplicar filtro si ya se seleccionó uno
            if(selectedMatrix) applyMatrixToImage();
        }
        originalImg.src = event.target.result;
    }
    reader.readAsDataURL(file);
});

function applyMatrixToImage(){
    if(!selectedMatrix) return;
    
    // Redibujar imagen limpia antes de filtrar
    imgCtx.drawImage(originalImg, 0, 0, imageCanvas.width, imageCanvas.height);

    let imgData = imgCtx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
    filterData(imgData.data);
    imgCtx.putImageData(imgData, 0, 0);
}

// ---------------- LÓGICA DE CÁMARA (OPTIMIZADA) ------------------
const videoElement = document.getElementById("videoElement");
const videoCanvas = document.getElementById("videoCanvas");
const vidCtx = videoCanvas.getContext("2d", { willReadFrequently: true }); 
// 'willReadFrequently' avisa al navegador que leeremos píxeles constantemente

function startCamera(){
    if(cameraRunning) return;

    // UI Updates
    document.getElementById("videoCanvas").style.display = "block";
    document.getElementById("imageCanvas").style.display = "none"; // Ocultar imagen estática
    document.getElementById("btnStart").style.display = "none";
    document.getElementById("btnStop").style.display = "block";

    const constraints = {
        audio: false,
        video: {
            facingMode: "environment", // Intenta cámara trasera
            width: { ideal: 640 },     // Pedimos resolución baja nativamente
            height: { ideal: 480 }
        }
    };

    navigator.mediaDevices.getUserMedia(constraints)
    .then(stream => {
        cameraStream = stream;
        videoElement.srcObject = stream;
        cameraRunning = true;
        videoElement.play();
        requestAnimationFrame(processCameraLoop);
    })
    .catch(err => {
        console.error(err);
        alert("Error al acceder a la cámara. Asegúrate de dar permisos o usar HTTPS.");
        stopCamera();
    });
}

function stopCamera(){
    cameraRunning = false;
    if(animationId) cancelAnimationFrame(animationId);

    if(cameraStream){
        cameraStream.getTracks().forEach(track => track.stop());
        cameraStream = null;
    }
    
    videoElement.srcObject = null;

    // UI Updates
    document.getElementById("videoCanvas").style.display = "none";
    document.getElementById("imageCanvas").style.display = "block";
    document.getElementById("btnStart").style.display = "block";
    document.getElementById("btnStop").style.display = "none";
}

function processCameraLoop(){
    if(!cameraRunning) return;

    if(videoElement.readyState === videoElement.HAVE_ENOUGH_DATA){
        
        // TRUCO DE RENDIMIENTO:
        // Forzamos el canvas interno a ser pequeño (ej. 400px ancho)
        // El CSS lo estirará para que se vea grande en el celular.
        const MAX_WIDTH = 400; 
        const scale = Math.min(1, MAX_WIDTH / videoElement.videoWidth);
        
        videoCanvas.width = videoElement.videoWidth * scale;
        videoCanvas.height = videoElement.videoHeight * scale;

        // Dibujar frame actual del video al canvas (redimensionado)
        vidCtx.drawImage(videoElement, 0, 0, videoCanvas.width, videoCanvas.height);

        // Si hay matriz seleccionada, manipular píxeles
        if(selectedMatrix){
            let frame = vidCtx.getImageData(0, 0, videoCanvas.width, videoCanvas.height);
            filterData(frame.data); // Usamos la función compartida
            vidCtx.putImageData(frame, 0, 0);
        }
    }

    animationId = requestAnimationFrame(processCameraLoop);
}

// ---------------- FUNCIÓN DE FILTRADO COMPARTIDA ------------------
// Esta función hace la matemática pura para no repetir código
function filterData(data){
    let m = selectedMatrix;
    for(let i=0; i<data.length; i+=4){
        let r = data[i];
        let g = data[i+1];
        let b = data[i+2];

        // Multiplicación de matriz
        let nr = r*m[0][0] + g*m[0][1] + b*m[0][2];
        let ng = r*m[1][0] + g*m[1][1] + b*m[1][2];
        let nb = r*m[2][0] + g*m[2][1] + b*m[2][2];

        data[i]   = nr; 
        data[i+1] = ng; 
        data[i+2] = nb;
        // Alpha (data[i+3]) se deja igual
    }
}
</script>

</body>
</html>



